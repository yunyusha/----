<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

<script type="text/javascript">
    /*
    * ES6中具备完善的面向对象的概念
    * 类的定义
    *
    * JS中对象没有私有属性,所用的属性默认都是公开的
    *
    * 在面向对象中如果方法前面添加static,此时方法的作用权限属于
    * 当前类,该方法只能被当前类调用,此时方法中的this关键字就指代
    * 当前类
    *   综上:在js面向对象中每一个方法内部的this都指向该方法的调用者
    * */
    class Person{
        //constructor():构造方法,作用是创建一个对应的Person对象,等价于Python
        // 中的__init__方法,注意js面向对象中没有self概念,所有的对象都使用
        // this代表
        constructor(name,age,sex){
            this.name = name;
            this.age = age;
            this.sex =sex;
        }
      static print() {
          console.log(`我叫${this.name},今年${this.age},岁,性别${this.sex}`);
      }
        out(){
            console.log(`我叫${this.name},今年${this.age},岁,性别${this.sex}`);
        }
    }
//    ES6对象的创建
    let per = new Person('xiaosha',20,'男');
    per.birth = '2017-08-19';
    // per.print();
    Person.print();
//    JS中简单定义一个对象
    let obj = {'name':'xiaocai','age':20,'sex':'男'};

    //类的继承
    /*
    * 在js中类的继承,使用关键字extends, 同时在子类的constructor中必须先调用
    * 其父类的constructor,调用方式通过super()方法调用
    *
    * super在js中存在两种方式
    * 第一种:函数方式super(),此时super()就指代父级的constructor方法
    *
    * 第二种:对象方式,用在普通方法中,此时相当于告诉浏览器在执行某一操作
    * 时需要按照父级的实现方法调用,该操作一般应用在对父级方法的功能
    * 的扩充方面
    * */
    class Stu extends Person {
        constructor(name, age, sex, sno) {
            super(name, age, sex);
            this.sno = sno;
        }
        out(){
            super.out();
            console.log(`我的学号是${this.sno}`);
        }
    }
    let stu = new Stu('xx',20,'ss',545564664646)
    stu.out();
</script>
</body>
</html>